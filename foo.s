
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

section .data
const_tbl:
MAKE_BOOL(1)
MAKE_BOOL(0)
MAKE_NIL
MAKE_VOID
MAKE_LITERAL_STRING {36}, 1
MAKE_LITERAL_SYMBOl(const_tbl+6)
MAKE_LITERAL_STRING {119,104,97,116,101,118,101,114}, 8
MAKE_LITERAL_SYMBOl(const_tbl+25)
MAKE_LITERAL_INT(1)
MAKE_LITERAL_INT(0)
MAKE_LITERAL_CHAR (0)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+5
%define SOB_NIL_ADDRESS const_tbl+4
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+0

fvar_tbl:
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED

global main
extern memmove
section .text
main:
    push rbp

    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push SOB_NIL_ADDRESS
    push -1
    push rsp
    mov rbp,rsp

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_boolean)
    mov [fvar_tbl+8*0], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_float)
    mov [fvar_tbl+8*1], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_integer)
    mov [fvar_tbl+8*2], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_pair)
    mov [fvar_tbl+8*3], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_null)
    mov [fvar_tbl+8*4], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_char)
    mov [fvar_tbl+8*5], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_string)
    mov [fvar_tbl+8*6], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_procedure)
    mov [fvar_tbl+8*7], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_symbol)
    mov [fvar_tbl+8*8], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
    mov [fvar_tbl+8*9], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
    mov [fvar_tbl+8*10], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
    mov [fvar_tbl+8*11], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
    mov [fvar_tbl+8*12], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
    mov [fvar_tbl+8*13], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
    mov [fvar_tbl+8*14], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
    mov [fvar_tbl+8*15], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_eq)
    mov [fvar_tbl+8*16], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_add)
    mov [fvar_tbl+8*17], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_mul)
    mov [fvar_tbl+8*18], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_sub)
    mov [fvar_tbl+8*19], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_div)
    mov [fvar_tbl+8*20], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_lt)
    mov [fvar_tbl+8*21], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_equ)
    mov [fvar_tbl+8*22], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
    mov [fvar_tbl+8*23], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
    mov [fvar_tbl+8*24], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
    mov [fvar_tbl+8*25], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
    mov [fvar_tbl+8*28], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
    mov [fvar_tbl+8*26], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
    mov [fvar_tbl+8*27], rax

user_code_fragment:
;;; The code you compiled will be catenated here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.

push 496351

mov rax, qword[fvar_tbl+28*8]
push rax
mov rax, qword[fvar_tbl+23*8]
push rax
mov rax, qword[fvar_tbl+25*8]
push rax
mov rax, qword[fvar_tbl+24*8]
push rax
mov rax, qword[fvar_tbl+4*8]
push rax
push 5
;(LambdaSimple'(  ( null? , car , cdr , cons , apply ) , [ApplicTP'( (LambdaSimple'(  ( map-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( map-loop , 0 )) , (Box'( VarParam ( map-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( map-loop , 0 ) , (LambdaOpt'(  ( f , l . ls ), , [(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( l , 1 ))] ) , Const' ( Nil),(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( ls , 2 ))] ) , ApplicTP'( Var' ( VarBound ( cons , 1 , 1 )) , [Applic'( Var' ( VarParam ( f , 0 )) , [Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( l , 1 ))] )] ) , Applic'( (BoxGet'( VarBound ( map-loop , 0 , 0 ) ) , [Var' ( VarParam ( f , 0 )) , Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( l , 1 ))] )] )] ),ApplicTP'( Var' ( VarBound ( cons , 1 , 1 )) , [Applic'( Var' ( VarBound ( apply , 1 , 1 )) , [Var' ( VarParam ( f , 0 )) , Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( l , 1 ))] ) , Applic'( (BoxGet'( VarBound ( map-loop , 0 , 0 ) ) , [Var' ( VarBound ( car , 1 , 1 )) , Var' ( VarParam ( ls , 2 ))] )] ) , Applic'( Var' ( VarBound ( apply , 1 , 1 )) , [Var' ( VarFree ( map )) , Var' ( VarParam ( f , 0 )) , Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( l , 1 ))] ) , Applic'( (BoxGet'( VarBound ( map-loop , 0 , 0 ) ) , [Var' ( VarBound ( cdr , 1 , 1 )) , Var' ( VarParam ( ls , 2 ))] )] )] ) ) )] ) ) , (BoxGet'( VarParam ( map-loop , 0 ) )] )] )] ) , [Const' ( Symbol(whatever))] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_36
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_37
is_not_empty_36:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_38:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_38
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_40
params_loop_39:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_39
no_more_params_40:
mov qword[rdx], rbx
is_empty_37:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_41)
jmp Lcont_42
Lcode_41:
push rbp
mov rbp, rsp
push 496351

mov rax, const_tbl+42
push rax
push 1
;(LambdaSimple'(  ( map-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( map-loop , 0 )) , (Box'( VarParam ( map-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( map-loop , 0 ) , (LambdaOpt'(  ( f , l . ls ), , [(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( l , 1 ))] ) , Const' ( Nil),(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( ls , 2 ))] ) , ApplicTP'( Var' ( VarBound ( cons , 1 , 1 )) , [Applic'( Var' ( VarParam ( f , 0 )) , [Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( l , 1 ))] )] ) , Applic'( (BoxGet'( VarBound ( map-loop , 0 , 0 ) ) , [Var' ( VarParam ( f , 0 )) , Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( l , 1 ))] )] )] ),ApplicTP'( Var' ( VarBound ( cons , 1 , 1 )) , [Applic'( Var' ( VarBound ( apply , 1 , 1 )) , [Var' ( VarParam ( f , 0 )) , Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( l , 1 ))] ) , Applic'( (BoxGet'( VarBound ( map-loop , 0 , 0 ) ) , [Var' ( VarBound ( car , 1 , 1 )) , Var' ( VarParam ( ls , 2 ))] )] ) , Applic'( Var' ( VarBound ( apply , 1 , 1 )) , [Var' ( VarFree ( map )) , Var' ( VarParam ( f , 0 )) , Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( l , 1 ))] ) , Applic'( (BoxGet'( VarBound ( map-loop , 0 , 0 ) ) , [Var' ( VarBound ( cdr , 1 , 1 )) , Var' ( VarParam ( ls , 2 ))] )] )] ) ) )] ) ) , (BoxGet'( VarParam ( map-loop , 0 ) )] )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_53
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_54
is_not_empty_53:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_55:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_55
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_57
params_loop_56:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_56
no_more_params_57:
mov qword[rdx], rbx
is_empty_54:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_58)
jmp Lcont_59
Lcode_58:
push rbp
mov rbp, rsp
mov rax, qword [rbp+8*(4+0)]
MALLOC rbx, 8
mov qword[rbx], rax
mov rax, rbx
mov qword [rbp+8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_95
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_96
is_not_empty_95:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_97:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_97
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_99
params_loop_98:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_98
no_more_params_99:
mov qword[rdx], rbx
is_empty_96:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_100)
jmp Lcont_101
Lcode_100:
;donte the effective numer of parameters m
;donte the number of simple parameters n
mov rcx, qword[rsp+ 8*2]; rcx is m
cmp rcx, 2
jne not_empty_opt_102
; m = n
add rcx, 3;m+2 - offset of magic
shl rcx, 3
mov qword[rsp+rcx], SOB_NIL_ADDRESS; magic is NIL
jmp done_fixing_103
not_empty_opt_102:
add rcx, 2; rcx is m+2 - the offset of the ultimetly last argument
mov rdi, rcx
mov rbx, qword[rsp+8*rdi]
MAKE_PAIR(rdx, rbx, SOB_NIL_ADDRESS)
mov qword[rsp+8*rdi], rdx;Arg_m-1 contains '(Arg_n-1)
sub rcx, 2; rcx is m
sub rcx, 2; rcx is m-n
dec rcx; because we've already handled the top opt param
cmp rcx, 0
je done_fixing_103
;rcx is the number of optional parameters left (i.e. (m-n)-1)
create_opt_loop_104:
mov rdx, rcx; rdx is curr_m (i.e: (m-n) - i, i.e the current amount of not consumed optional args left)
dec rdx; rdx is now offset
add rdx, 3; offset of arg_0+(curr_m-1)
add rdx, 2; offset of last optional param not consumed
mov rbx, qword[rsp + 8*rdx]
mov rdi, qword[rsp + 8*(rdx +1)]
MAKE_PAIR(rsi, rbx, rdi)
mov qword[rsp + 8*(rdx +1)], rsi
mov rax, 0
mov rdi, rsp
add rdi, 8; destination
mov rsi, rsp;source
mov rdx, 2;n
add rdx, 3; n+3
add rdx, rcx;n+3+curr_m
dec rdx; because the last opttion param have been consumed
shl rdx, 3
push rcx
call memmove
pop rcx
mov rsp, rax
sub qword[rsp +2*8], 1
loop create_opt_loop_104
done_fixing_103:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( null? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_347
mov rax, const_tbl+4
jmp Lexit_348
Lelse_347:
push 496351

mov rax, qword [rbp+8*(4+2)]
push rax
push 1
;Var' ( VarBound ( null? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_345
push 496351

push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( cdr , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*2]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;(BoxGet'( VarBound ( map-loop , 0 , 0 ) )
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]
mov rax, qword[rax]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( car , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 1
;Var' ( VarParam ( f , 0 ))
mov rax, qword [rbp+8*(4+0)]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 2
;Var' ( VarBound ( cons , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*3]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
jmp Lexit_346
Lelse_345:
push 496351

push 496351

push 496351

mov rax, qword [rbp+8*(4+2)]
push rax
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*2]
push rax
push 2
;(BoxGet'( VarBound ( map-loop , 0 , 0 ) )
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]
mov rax, qword[rax]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( cdr , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*2]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
mov rax, qword[fvar_tbl+29*8]
push rax
push 4
;Var' ( VarBound ( apply , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*4]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 496351

push 496351

mov rax, qword [rbp+8*(4+2)]
push rax
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*1]
push rax
push 2
;(BoxGet'( VarBound ( map-loop , 0 , 0 ) )
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]
mov rax, qword[rax]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( car , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 3
;Var' ( VarBound ( apply , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*4]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 2
;Var' ( VarBound ( cons , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*3]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
Lexit_346:
Lexit_348:
leave
ret
Lcont_101:
push rax
mov rax, qword [rbp+8*(4+0)]
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp+8*(4+0)]
mov rax, qword[rax]
leave
ret
Lcont_59:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 5
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_42:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+29*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+25*8]
push rax
mov rax, qword[fvar_tbl+24*8]
push rax
mov rax, qword[fvar_tbl+4*8]
push rax
push 3
;(LambdaSimple'(  ( null? , car , cdr ) , [ApplicTP'( (LambdaSimple'(  ( fold-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( fold-loop , 0 )) , (Box'( VarParam ( fold-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( fold-loop , 0 ) , (LambdaSimple'(  ( f , acc , l ) , [(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( l , 2 ))] ) , Var' ( VarParam ( acc , 1 )),ApplicTP'( (BoxGet'( VarBound ( fold-loop , 0 , 0 ) ) , [Var' ( VarParam ( f , 0 )) , Applic'( Var' ( VarParam ( f , 0 )) , [Var' ( VarParam ( acc , 1 )) , Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( l , 2 ))] )] ) , Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( l , 2 ))] )] ) )] ) ) , (BoxGet'( VarParam ( fold-loop , 0 ) )] )] )] ) , [Const' ( Symbol(whatever))] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_384
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_385
is_not_empty_384:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_386:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_386
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_388
params_loop_387:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_387
no_more_params_388:
mov qword[rdx], rbx
is_empty_385:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_389)
jmp Lcont_390
Lcode_389:
push rbp
mov rbp, rsp
push 496351

mov rax, const_tbl+42
push rax
push 1
;(LambdaSimple'(  ( fold-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( fold-loop , 0 )) , (Box'( VarParam ( fold-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( fold-loop , 0 ) , (LambdaSimple'(  ( f , acc , l ) , [(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( l , 2 ))] ) , Var' ( VarParam ( acc , 1 )),ApplicTP'( (BoxGet'( VarBound ( fold-loop , 0 , 0 ) ) , [Var' ( VarParam ( f , 0 )) , Applic'( Var' ( VarParam ( f , 0 )) , [Var' ( VarParam ( acc , 1 )) , Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( l , 2 ))] )] ) , Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( l , 2 ))] )] ) )] ) ) , (BoxGet'( VarParam ( fold-loop , 0 ) )] )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_401
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_402
is_not_empty_401:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_403:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_403
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_405
params_loop_404:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_404
no_more_params_405:
mov qword[rdx], rbx
is_empty_402:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_406)
jmp Lcont_407
Lcode_406:
push rbp
mov rbp, rsp
mov rax, qword [rbp+8*(4+0)]
MALLOC rbx, 8
mov qword[rbx], rax
mov rax, rbx
mov qword [rbp+8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_443
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_444
is_not_empty_443:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_445:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_445
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_447
params_loop_446:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_446
no_more_params_447:
mov qword[rdx], rbx
is_empty_444:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_448)
jmp Lcont_449
Lcode_448:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+2)]
push rax
push 1
;Var' ( VarBound ( null? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_540
mov rax, qword [rbp+8*(4+1)]
jmp Lexit_541
Lelse_540:
push 496351

push 496351

mov rax, qword [rbp+8*(4+2)]
push rax
push 1
;Var' ( VarBound ( cdr , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*2]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 496351

push 496351

mov rax, qword [rbp+8*(4+2)]
push rax
push 1
;Var' ( VarBound ( car , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
mov rax, qword [rbp+8*(4+1)]
push rax
push 2
;Var' ( VarParam ( f , 0 ))
mov rax, qword [rbp+8*(4+0)]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 3
;(BoxGet'( VarBound ( fold-loop , 0 , 0 ) )
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]
mov rax, qword[rax]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 7
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
Lexit_541:
leave
ret
Lcont_449:
push rax
mov rax, qword [rbp+8*(4+0)]
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp+8*(4+0)]
mov rax, qword[rax]
leave
ret
Lcont_407:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 5
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_390:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+30*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+25*8]
push rax
mov rax, qword[fvar_tbl+24*8]
push rax
mov rax, qword[fvar_tbl+4*8]
push rax
push 3
;(LambdaSimple'(  ( null? , car , cdr ) , [ApplicTP'( (LambdaSimple'(  ( fold-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( fold-loop , 0 )) , (Box'( VarParam ( fold-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( fold-loop , 0 ) , (LambdaSimple'(  ( f , acc , l ) , [(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( l , 2 ))] ) , Var' ( VarParam ( acc , 1 )),ApplicTP'( Var' ( VarParam ( f , 0 )) , [Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( l , 2 ))] ) , Applic'( (BoxGet'( VarBound ( fold-loop , 0 , 0 ) ) , [Var' ( VarParam ( f , 0 )) , Var' ( VarParam ( acc , 1 )) , Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( l , 2 ))] )] )] ) )] ) ) , (BoxGet'( VarParam ( fold-loop , 0 ) )] )] )] ) , [Const' ( Symbol(whatever))] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_577
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_578
is_not_empty_577:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_579:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_579
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_581
params_loop_580:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_580
no_more_params_581:
mov qword[rdx], rbx
is_empty_578:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_582)
jmp Lcont_583
Lcode_582:
push rbp
mov rbp, rsp
push 496351

mov rax, const_tbl+42
push rax
push 1
;(LambdaSimple'(  ( fold-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( fold-loop , 0 )) , (Box'( VarParam ( fold-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( fold-loop , 0 ) , (LambdaSimple'(  ( f , acc , l ) , [(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( l , 2 ))] ) , Var' ( VarParam ( acc , 1 )),ApplicTP'( Var' ( VarParam ( f , 0 )) , [Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( l , 2 ))] ) , Applic'( (BoxGet'( VarBound ( fold-loop , 0 , 0 ) ) , [Var' ( VarParam ( f , 0 )) , Var' ( VarParam ( acc , 1 )) , Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( l , 2 ))] )] )] ) )] ) ) , (BoxGet'( VarParam ( fold-loop , 0 ) )] )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_594
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_595
is_not_empty_594:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_596:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_596
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_598
params_loop_597:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_597
no_more_params_598:
mov qword[rdx], rbx
is_empty_595:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_599)
jmp Lcont_600
Lcode_599:
push rbp
mov rbp, rsp
mov rax, qword [rbp+8*(4+0)]
MALLOC rbx, 8
mov qword[rbx], rax
mov rax, rbx
mov qword [rbp+8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_636
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_637
is_not_empty_636:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_638:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_638
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_640
params_loop_639:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_639
no_more_params_640:
mov qword[rdx], rbx
is_empty_637:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_641)
jmp Lcont_642
Lcode_641:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+2)]
push rax
push 1
;Var' ( VarBound ( null? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_733
mov rax, qword [rbp+8*(4+1)]
jmp Lexit_734
Lelse_733:
push 496351

push 496351

push 496351

mov rax, qword [rbp+8*(4+2)]
push rax
push 1
;Var' ( VarBound ( cdr , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*2]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
mov rax, qword [rbp+8*(4+1)]
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 3
;(BoxGet'( VarBound ( fold-loop , 0 , 0 ) )
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]
mov rax, qword[rax]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 496351

mov rax, qword [rbp+8*(4+2)]
push rax
push 1
;Var' ( VarBound ( car , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 2
;Var' ( VarParam ( f , 0 ))
mov rax, qword [rbp+8*(4+0)]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
Lexit_734:
leave
ret
Lcont_642:
push rax
mov rax, qword [rbp+8*(4+0)]
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp+8*(4+0)]
mov rax, qword[rax]
leave
ret
Lcont_600:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 5
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_583:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+31*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+28*8]
push rax
mov rax, qword[fvar_tbl+23*8]
push rax
mov rax, qword[fvar_tbl+25*8]
push rax
mov rax, qword[fvar_tbl+24*8]
push rax
mov rax, qword[fvar_tbl+4*8]
push rax
push 5
;(LambdaSimple'(  ( null? , car , cdr , cons , apply ) , [ApplicTP'( (LambdaSimple'(  ( cons-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( cons-loop , 0 )) , (Box'( VarParam ( cons-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( cons-loop , 0 ) , (LambdaOpt'(  ( x . l ), , [(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( l , 1 ))] ) , Var' ( VarParam ( x , 0 )),ApplicTP'( Var' ( VarBound ( cons , 1 , 1 )) , [Var' ( VarParam ( x , 0 )) , Applic'( Var' ( VarBound ( apply , 1 , 1 )) , [(BoxGet'( VarBound ( cons-loop , 0 , 0 ) ) , Var' ( VarParam ( l , 1 ))] )] ) )] ) ) , (BoxGet'( VarParam ( cons-loop , 0 ) )] )] )] ) , [Const' ( Symbol(whatever))] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_780
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_781
is_not_empty_780:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_782:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_782
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_784
params_loop_783:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_783
no_more_params_784:
mov qword[rdx], rbx
is_empty_781:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_785)
jmp Lcont_786
Lcode_785:
push rbp
mov rbp, rsp
push 496351

mov rax, const_tbl+42
push rax
push 1
;(LambdaSimple'(  ( cons-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( cons-loop , 0 )) , (Box'( VarParam ( cons-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( cons-loop , 0 ) , (LambdaOpt'(  ( x . l ), , [(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( l , 1 ))] ) , Var' ( VarParam ( x , 0 )),ApplicTP'( Var' ( VarBound ( cons , 1 , 1 )) , [Var' ( VarParam ( x , 0 )) , Applic'( Var' ( VarBound ( apply , 1 , 1 )) , [(BoxGet'( VarBound ( cons-loop , 0 , 0 ) ) , Var' ( VarParam ( l , 1 ))] )] ) )] ) ) , (BoxGet'( VarParam ( cons-loop , 0 ) )] )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_797
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_798
is_not_empty_797:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_799:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_799
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_801
params_loop_800:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_800
no_more_params_801:
mov qword[rdx], rbx
is_empty_798:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_802)
jmp Lcont_803
Lcode_802:
push rbp
mov rbp, rsp
mov rax, qword [rbp+8*(4+0)]
MALLOC rbx, 8
mov qword[rbx], rax
mov rax, rbx
mov qword [rbp+8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_839
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_840
is_not_empty_839:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_841:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_841
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_843
params_loop_842:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_842
no_more_params_843:
mov qword[rdx], rbx
is_empty_840:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_844)
jmp Lcont_845
Lcode_844:
;donte the effective numer of parameters m
;donte the number of simple parameters n
mov rcx, qword[rsp+ 8*2]; rcx is m
cmp rcx, 1
jne not_empty_opt_846
; m = n
add rcx, 3;m+2 - offset of magic
shl rcx, 3
mov qword[rsp+rcx], SOB_NIL_ADDRESS; magic is NIL
jmp done_fixing_847
not_empty_opt_846:
add rcx, 2; rcx is m+2 - the offset of the ultimetly last argument
mov rdi, rcx
mov rbx, qword[rsp+8*rdi]
MAKE_PAIR(rdx, rbx, SOB_NIL_ADDRESS)
mov qword[rsp+8*rdi], rdx;Arg_m-1 contains '(Arg_n-1)
sub rcx, 2; rcx is m
sub rcx, 1; rcx is m-n
dec rcx; because we've already handled the top opt param
cmp rcx, 0
je done_fixing_847
;rcx is the number of optional parameters left (i.e. (m-n)-1)
create_opt_loop_848:
mov rdx, rcx; rdx is curr_m (i.e: (m-n) - i, i.e the current amount of not consumed optional args left)
dec rdx; rdx is now offset
add rdx, 3; offset of arg_0+(curr_m-1)
add rdx, 1; offset of last optional param not consumed
mov rbx, qword[rsp + 8*rdx]
mov rdi, qword[rsp + 8*(rdx +1)]
MAKE_PAIR(rsi, rbx, rdi)
mov qword[rsp + 8*(rdx +1)], rsi
mov rax, 0
mov rdi, rsp
add rdi, 8; destination
mov rsi, rsp;source
mov rdx, 1;n
add rdx, 3; n+3
add rdx, rcx;n+3+curr_m
dec rdx; because the last opttion param have been consumed
shl rdx, 3
push rcx
call memmove
pop rcx
mov rsp, rax
sub qword[rsp +2*8], 1
loop create_opt_loop_848
done_fixing_847:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( null? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_914
mov rax, qword [rbp+8*(4+0)]
jmp Lexit_915
Lelse_914:
push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]
mov rax, qword[rax]
push rax
push 2
;Var' ( VarBound ( apply , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*4]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;Var' ( VarBound ( cons , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*3]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
Lexit_915:
leave
ret
Lcont_845:
push rax
mov rax, qword [rbp+8*(4+0)]
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp+8*(4+0)]
mov rax, qword[rax]
leave
ret
Lcont_803:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 5
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_786:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+32*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+23*8]
push rax
mov rax, qword[fvar_tbl+31*8]
push rax
mov rax, qword[fvar_tbl+4*8]
push rax
push 3
;(LambdaSimple'(  ( null? , fold-right , cons ) , [(LambdaOpt'(  (  . args ), , [ApplicTP'( Var' ( VarBound ( fold-right , 0 , 0 )) , [(LambdaSimple'(  ( e , a ) , [(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( a , 1 ))] ) , Var' ( VarParam ( e , 0 )),ApplicTP'( Var' ( VarBound ( fold-right , 1 , 1 )) , [Var' ( VarBound ( cons , 1 , 1 )) , Var' ( VarParam ( a , 1 )) , Var' ( VarParam ( e , 0 ))] ) )] ) , Const' ( Nil) , Var' ( VarParam ( args , 0 ))] )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_951
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_952
is_not_empty_951:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_953:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_953
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_955
params_loop_954:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_954
no_more_params_955:
mov qword[rdx], rbx
is_empty_952:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_956)
jmp Lcont_957
Lcode_956:
push rbp
mov rbp, rsp
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_958
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_959
is_not_empty_958:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_960:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_960
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_962
params_loop_961:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_961
no_more_params_962:
mov qword[rdx], rbx
is_empty_959:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_963)
jmp Lcont_964
Lcode_963:
;donte the effective numer of parameters m
;donte the number of simple parameters n
mov rcx, qword[rsp+ 8*2]; rcx is m
cmp rcx, 0
jne not_empty_opt_965
; m = n
add rcx, 3;m+2 - offset of magic
shl rcx, 3
mov qword[rsp+rcx], SOB_NIL_ADDRESS; magic is NIL
jmp done_fixing_966
not_empty_opt_965:
add rcx, 2; rcx is m+2 - the offset of the ultimetly last argument
mov rdi, rcx
mov rbx, qword[rsp+8*rdi]
MAKE_PAIR(rdx, rbx, SOB_NIL_ADDRESS)
mov qword[rsp+8*rdi], rdx;Arg_m-1 contains '(Arg_n-1)
sub rcx, 2; rcx is m
sub rcx, 0; rcx is m-n
dec rcx; because we've already handled the top opt param
cmp rcx, 0
je done_fixing_966
;rcx is the number of optional parameters left (i.e. (m-n)-1)
create_opt_loop_967:
mov rdx, rcx; rdx is curr_m (i.e: (m-n) - i, i.e the current amount of not consumed optional args left)
dec rdx; rdx is now offset
add rdx, 3; offset of arg_0+(curr_m-1)
add rdx, 0; offset of last optional param not consumed
mov rbx, qword[rsp + 8*rdx]
mov rdi, qword[rsp + 8*(rdx +1)]
MAKE_PAIR(rsi, rbx, rdi)
mov qword[rsp + 8*(rdx +1)], rsi
mov rax, 0
mov rdi, rsp
add rdi, 8; destination
mov rsi, rsp;source
mov rdx, 0;n
add rdx, 3; n+3
add rdx, rcx;n+3+curr_m
dec rdx; because the last opttion param have been consumed
shl rdx, 3
push rcx
call memmove
pop rcx
mov rsp, rax
sub qword[rsp +2*8], 1
loop create_opt_loop_967
done_fixing_966:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
mov rax, const_tbl+4
push rax
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_983
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_984
is_not_empty_983:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_985:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_985
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_987
params_loop_986:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_986
no_more_params_987:
mov qword[rdx], rbx
is_empty_984:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_988)
jmp Lcont_989
Lcode_988:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( null? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_1040
mov rax, qword [rbp+8*(4+0)]
jmp Lexit_1041
Lelse_1040:
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
mov rax, qword [rbp+8*(4+1)]
push rax
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*2]
push rax
push 3
;Var' ( VarBound ( fold-right , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 7
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
Lexit_1041:
leave
ret
Lcont_989:
push rax
push 3
;Var' ( VarBound ( fold-right , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 7
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_964:
leave
ret
Lcont_957:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+33*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1052
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1053
is_not_empty_1052:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1054:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1054
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1056
params_loop_1055:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1055
no_more_params_1056:
mov qword[rdx], rbx
is_empty_1053:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1057)
jmp Lcont_1058
Lcode_1057:
;donte the effective numer of parameters m
;donte the number of simple parameters n
mov rcx, qword[rsp+ 8*2]; rcx is m
cmp rcx, 0
jne not_empty_opt_1059
; m = n
add rcx, 3;m+2 - offset of magic
shl rcx, 3
mov qword[rsp+rcx], SOB_NIL_ADDRESS; magic is NIL
jmp done_fixing_1060
not_empty_opt_1059:
add rcx, 2; rcx is m+2 - the offset of the ultimetly last argument
mov rdi, rcx
mov rbx, qword[rsp+8*rdi]
MAKE_PAIR(rdx, rbx, SOB_NIL_ADDRESS)
mov qword[rsp+8*rdi], rdx;Arg_m-1 contains '(Arg_n-1)
sub rcx, 2; rcx is m
sub rcx, 0; rcx is m-n
dec rcx; because we've already handled the top opt param
cmp rcx, 0
je done_fixing_1060
;rcx is the number of optional parameters left (i.e. (m-n)-1)
create_opt_loop_1061:
mov rdx, rcx; rdx is curr_m (i.e: (m-n) - i, i.e the current amount of not consumed optional args left)
dec rdx; rdx is now offset
add rdx, 3; offset of arg_0+(curr_m-1)
add rdx, 0; offset of last optional param not consumed
mov rbx, qword[rsp + 8*rdx]
mov rdi, qword[rsp + 8*(rdx +1)]
MAKE_PAIR(rsi, rbx, rdi)
mov qword[rsp + 8*(rdx +1)], rsi
mov rax, 0
mov rdi, rsp
add rdi, 8; destination
mov rsi, rsp;source
mov rdx, 0;n
add rdx, 3; n+3
add rdx, rcx;n+3+curr_m
dec rdx; because the last opttion param have been consumed
shl rdx, 3
push rcx
call memmove
pop rcx
mov rsp, rax
sub qword[rsp +2*8], 1
loop create_opt_loop_1061
done_fixing_1060:
push rbp
mov rbp, rsp
mov rax, qword [rbp+8*(4+0)]
leave
ret
Lcont_1058:
mov qword[fvar_tbl+34*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+25*8]
push rax
mov rax, qword[fvar_tbl+3*8]
push rax
mov rax, qword[fvar_tbl+4*8]
push rax
push 3
;(LambdaSimple'(  ( null? , pair? , cdr ) , [ApplicTP'( (LambdaSimple'(  ( list?-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( list?-loop , 0 )) , (LambdaSimple'(  ( x ) , [(Or'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , (If'( Applic'( Var' ( VarBound ( pair? , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , ApplicTP'( Var' ( VarFree ( list? )) , [Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] )] ),Const' ( false) ) )] ) ) , Var' ( VarParam ( list?-loop , 0 ))] )] ) , [Const' ( Symbol(whatever))] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1092
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1093
is_not_empty_1092:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1094:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1094
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1096
params_loop_1095:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1095
no_more_params_1096:
mov qword[rdx], rbx
is_empty_1093:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1097)
jmp Lcont_1098
Lcode_1097:
push rbp
mov rbp, rsp
push 496351

mov rax, const_tbl+42
push rax
push 1
;(LambdaSimple'(  ( list?-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( list?-loop , 0 )) , (LambdaSimple'(  ( x ) , [(Or'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , (If'( Applic'( Var' ( VarBound ( pair? , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , ApplicTP'( Var' ( VarFree ( list? )) , [Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] )] ),Const' ( false) ) )] ) ) , Var' ( VarParam ( list?-loop , 0 ))] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1109
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1110
is_not_empty_1109:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1111:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1111
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1113
params_loop_1112:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1112
no_more_params_1113:
mov qword[rdx], rbx
is_empty_1110:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1114)
jmp Lcont_1115
Lcode_1114:
push rbp
mov rbp, rsp
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1126
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1127
is_not_empty_1126:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1128:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1128
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1130
params_loop_1129:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1129
no_more_params_1130:
mov qword[rdx], rbx
is_empty_1127:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1131)
jmp Lcont_1132
Lcode_1131:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
push 1
;Var' ( VarBound ( null? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS 
 jne Lexit_1138 
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
push 1
;Var' ( VarBound ( pair? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_1204
push 496351

push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
push 1
;Var' ( VarBound ( cdr , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*2]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 1
;Var' ( VarFree ( list? ))
mov rax, qword[fvar_tbl+35*8]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 5
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
jmp Lexit_1205
Lelse_1204:
mov rax, const_tbl+2
Lexit_1205:
Lexit_1138:

leave
ret
Lcont_1132:
mov qword [rbp+8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp+8*(4+0)]
leave
ret
Lcont_1115:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 5
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_1098:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+35*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+17*8]
push rax
mov rax, qword[fvar_tbl+30*8]
push rax
push 2
;(LambdaSimple'(  ( fold-left , + ) , [(LambdaSimple'(  ( l ) , [ApplicTP'( Var' ( VarBound ( fold-left , 0 , 0 )) , [(LambdaSimple'(  ( acc , e ) , [ApplicTP'( Var' ( VarBound ( + , 1 , 1 )) , [Var' ( VarParam ( acc , 0 )) , Const' ( 1)] )] ) , Const' ( 0) , Var' ( VarParam ( l , 0 ))] )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1231
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1232
is_not_empty_1231:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1233:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1233
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1235
params_loop_1234:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1234
no_more_params_1235:
mov qword[rdx], rbx
is_empty_1232:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1236)
jmp Lcont_1237
Lcode_1236:
push rbp
mov rbp, rsp
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1238
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1239
is_not_empty_1238:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1240:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1240
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1242
params_loop_1241:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1241
no_more_params_1242:
mov qword[rdx], rbx
is_empty_1239:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1243)
jmp Lcont_1244
Lcode_1243:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
mov rax, const_tbl+60
push rax
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1260
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1261
is_not_empty_1260:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1262:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1262
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1264
params_loop_1263:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1263
no_more_params_1264:
mov qword[rdx], rbx
is_empty_1261:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1265)
jmp Lcont_1266
Lcode_1265:
push rbp
mov rbp, rsp
push 496351

mov rax, const_tbl+51
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;Var' ( VarBound ( + , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_1266:
push rax
push 3
;Var' ( VarBound ( fold-left , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 7
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_1244:
leave
ret
Lcont_1237:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+36*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+12*8]
push rax
mov rax, qword[fvar_tbl+24*8]
push rax
mov rax, qword[fvar_tbl+4*8]
push rax
push 3
;(LambdaSimple'(  ( null? , car , make-string ) , [(LambdaOpt'(  ( x . y ), , [(If'( Applic'( Var' ( VarBound ( null? , 0 , 0 )) , [Var' ( VarParam ( y , 1 ))] ) , ApplicTP'( Var' ( VarBound ( make-string , 0 , 0 )) , [Var' ( VarParam ( x , 0 )) , Const' ( Char( ))] ),ApplicTP'( Var' ( VarBound ( make-string , 0 , 0 )) , [Var' ( VarParam ( x , 0 )) , Applic'( Var' ( VarBound ( car , 0 , 0 )) , [Var' ( VarParam ( y , 1 ))] )] ) )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1317
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1318
is_not_empty_1317:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1319:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1319
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1321
params_loop_1320:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1320
no_more_params_1321:
mov qword[rdx], rbx
is_empty_1318:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1322)
jmp Lcont_1323
Lcode_1322:
push rbp
mov rbp, rsp
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1324
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1325
is_not_empty_1324:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1326:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1326
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1328
params_loop_1327:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1327
no_more_params_1328:
mov qword[rdx], rbx
is_empty_1325:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1329)
jmp Lcont_1330
Lcode_1329:
;donte the effective numer of parameters m
;donte the number of simple parameters n
mov rcx, qword[rsp+ 8*2]; rcx is m
cmp rcx, 1
jne not_empty_opt_1331
; m = n
add rcx, 3;m+2 - offset of magic
shl rcx, 3
mov qword[rsp+rcx], SOB_NIL_ADDRESS; magic is NIL
jmp done_fixing_1332
not_empty_opt_1331:
add rcx, 2; rcx is m+2 - the offset of the ultimetly last argument
mov rdi, rcx
mov rbx, qword[rsp+8*rdi]
MAKE_PAIR(rdx, rbx, SOB_NIL_ADDRESS)
mov qword[rsp+8*rdi], rdx;Arg_m-1 contains '(Arg_n-1)
sub rcx, 2; rcx is m
sub rcx, 1; rcx is m-n
dec rcx; because we've already handled the top opt param
cmp rcx, 0
je done_fixing_1332
;rcx is the number of optional parameters left (i.e. (m-n)-1)
create_opt_loop_1333:
mov rdx, rcx; rdx is curr_m (i.e: (m-n) - i, i.e the current amount of not consumed optional args left)
dec rdx; rdx is now offset
add rdx, 3; offset of arg_0+(curr_m-1)
add rdx, 1; offset of last optional param not consumed
mov rbx, qword[rsp + 8*rdx]
mov rdi, qword[rsp + 8*(rdx +1)]
MAKE_PAIR(rsi, rbx, rdi)
mov qword[rsp + 8*(rdx +1)], rsi
mov rax, 0
mov rdi, rsp
add rdi, 8; destination
mov rsi, rsp;source
mov rdx, 1;n
add rdx, 3; n+3
add rdx, rcx;n+3+curr_m
dec rdx; because the last opttion param have been consumed
shl rdx, 3
push rcx
call memmove
pop rcx
mov rsp, rax
sub qword[rsp +2*8], 1
loop create_opt_loop_1333
done_fixing_1332:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( null? , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_1404
push 496351

mov rax, const_tbl+69
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;Var' ( VarBound ( make-string , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*2]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
jmp Lexit_1405
Lelse_1404:
push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( car , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;Var' ( VarBound ( make-string , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*2]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
Lexit_1405:
leave
ret
Lcont_1330:
leave
ret
Lcont_1323:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+12*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1411
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1412
is_not_empty_1411:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1413:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1413
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1415
params_loop_1414:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1414
no_more_params_1415:
mov qword[rdx], rbx
is_empty_1412:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1416)
jmp Lcont_1417
Lcode_1416:
push rbp
mov rbp, rsp
mov rax, qword [rbp+8*(4+0)]
cmp rax, SOB_FALSE_ADDRESS
je Lelse_1438
mov rax, const_tbl+2
jmp Lexit_1439
Lelse_1438:
mov rax, const_tbl+0
Lexit_1439:
leave
ret
Lcont_1417:
mov qword[fvar_tbl+37*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+2*8]
push rax
mov rax, qword[fvar_tbl+1*8]
push rax
push 2
;(LambdaSimple'(  ( float? , integer? ) , [(LambdaSimple'(  ( x ) , [(Or'( Applic'( Var' ( VarBound ( float? , 0 , 0 )) , [Var' ( VarParam ( x , 0 ))] ) , ApplicTP'( Var' ( VarBound ( integer? , 0 , 0 )) , [Var' ( VarParam ( x , 0 ))] ) )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1460
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1461
is_not_empty_1460:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1462:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1462
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1464
params_loop_1463:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1463
no_more_params_1464:
mov qword[rdx], rbx
is_empty_1461:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1465)
jmp Lcont_1466
Lcode_1465:
push rbp
mov rbp, rsp
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1467
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1468
is_not_empty_1467:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1469:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1469
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1471
params_loop_1470:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1470
no_more_params_1471:
mov qword[rdx], rbx
is_empty_1468:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1472)
jmp Lcont_1473
Lcode_1472:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
push 1
;Var' ( VarBound ( float? , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS 
 jne Lexit_1479 
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
push 1
;Var' ( VarBound ( integer? , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 5
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
Lexit_1479:

leave
ret
Lcont_1473:
leave
ret
Lcont_1466:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+38*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+17*8]
push rax
mov rax, qword[fvar_tbl+30*8]
push rax
push 2
;(LambdaSimple'(  ( fold-left , + ) , [(LambdaOpt'(  (  . x ), , [ApplicTP'( Var' ( VarBound ( fold-left , 0 , 0 )) , [Var' ( VarBound ( + , 0 , 0 )) , Const' ( 0) , Var' ( VarParam ( x , 0 ))] )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1530
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1531
is_not_empty_1530:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1532:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1532
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1534
params_loop_1533:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1533
no_more_params_1534:
mov qword[rdx], rbx
is_empty_1531:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1535)
jmp Lcont_1536
Lcode_1535:
push rbp
mov rbp, rsp
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1537
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1538
is_not_empty_1537:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1539:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1539
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1541
params_loop_1540:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1540
no_more_params_1541:
mov qword[rdx], rbx
is_empty_1538:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1542)
jmp Lcont_1543
Lcode_1542:
;donte the effective numer of parameters m
;donte the number of simple parameters n
mov rcx, qword[rsp+ 8*2]; rcx is m
cmp rcx, 0
jne not_empty_opt_1544
; m = n
add rcx, 3;m+2 - offset of magic
shl rcx, 3
mov qword[rsp+rcx], SOB_NIL_ADDRESS; magic is NIL
jmp done_fixing_1545
not_empty_opt_1544:
add rcx, 2; rcx is m+2 - the offset of the ultimetly last argument
mov rdi, rcx
mov rbx, qword[rsp+8*rdi]
MAKE_PAIR(rdx, rbx, SOB_NIL_ADDRESS)
mov qword[rsp+8*rdi], rdx;Arg_m-1 contains '(Arg_n-1)
sub rcx, 2; rcx is m
sub rcx, 0; rcx is m-n
dec rcx; because we've already handled the top opt param
cmp rcx, 0
je done_fixing_1545
;rcx is the number of optional parameters left (i.e. (m-n)-1)
create_opt_loop_1546:
mov rdx, rcx; rdx is curr_m (i.e: (m-n) - i, i.e the current amount of not consumed optional args left)
dec rdx; rdx is now offset
add rdx, 3; offset of arg_0+(curr_m-1)
add rdx, 0; offset of last optional param not consumed
mov rbx, qword[rsp + 8*rdx]
mov rdi, qword[rsp + 8*(rdx +1)]
MAKE_PAIR(rsi, rbx, rdi)
mov qword[rsp + 8*(rdx +1)], rsi
mov rax, 0
mov rdi, rsp
add rdi, 8; destination
mov rsi, rsp;source
mov rdx, 0;n
add rdx, 3; n+3
add rdx, rcx;n+3+curr_m
dec rdx; because the last opttion param have been consumed
shl rdx, 3
push rcx
call memmove
pop rcx
mov rsp, rax
sub qword[rsp +2*8], 1
loop create_opt_loop_1546
done_fixing_1545:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
mov rax, const_tbl+60
push rax
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*1]
push rax
push 3
;Var' ( VarBound ( fold-left , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 7
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_1543:
leave
ret
Lcont_1536:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+17*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+18*8]
push rax
mov rax, qword[fvar_tbl+30*8]
push rax
push 2
;(LambdaSimple'(  ( fold-left , * ) , [(LambdaOpt'(  (  . x ), , [ApplicTP'( Var' ( VarBound ( fold-left , 0 , 0 )) , [Var' ( VarBound ( * , 0 , 0 )) , Const' ( 1) , Var' ( VarParam ( x , 0 ))] )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1592
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1593
is_not_empty_1592:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1594:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1594
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1596
params_loop_1595:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1595
no_more_params_1596:
mov qword[rdx], rbx
is_empty_1593:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1597)
jmp Lcont_1598
Lcode_1597:
push rbp
mov rbp, rsp
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1599
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1600
is_not_empty_1599:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1601:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1601
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1603
params_loop_1602:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1602
no_more_params_1603:
mov qword[rdx], rbx
is_empty_1600:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1604)
jmp Lcont_1605
Lcode_1604:
;donte the effective numer of parameters m
;donte the number of simple parameters n
mov rcx, qword[rsp+ 8*2]; rcx is m
cmp rcx, 0
jne not_empty_opt_1606
; m = n
add rcx, 3;m+2 - offset of magic
shl rcx, 3
mov qword[rsp+rcx], SOB_NIL_ADDRESS; magic is NIL
jmp done_fixing_1607
not_empty_opt_1606:
add rcx, 2; rcx is m+2 - the offset of the ultimetly last argument
mov rdi, rcx
mov rbx, qword[rsp+8*rdi]
MAKE_PAIR(rdx, rbx, SOB_NIL_ADDRESS)
mov qword[rsp+8*rdi], rdx;Arg_m-1 contains '(Arg_n-1)
sub rcx, 2; rcx is m
sub rcx, 0; rcx is m-n
dec rcx; because we've already handled the top opt param
cmp rcx, 0
je done_fixing_1607
;rcx is the number of optional parameters left (i.e. (m-n)-1)
create_opt_loop_1608:
mov rdx, rcx; rdx is curr_m (i.e: (m-n) - i, i.e the current amount of not consumed optional args left)
dec rdx; rdx is now offset
add rdx, 3; offset of arg_0+(curr_m-1)
add rdx, 0; offset of last optional param not consumed
mov rbx, qword[rsp + 8*rdx]
mov rdi, qword[rsp + 8*(rdx +1)]
MAKE_PAIR(rsi, rbx, rdi)
mov qword[rsp + 8*(rdx +1)], rsi
mov rax, 0
mov rdi, rsp
add rdi, 8; destination
mov rsi, rsp;source
mov rdx, 0;n
add rdx, 3; n+3
add rdx, rcx;n+3+curr_m
dec rdx; because the last opttion param have been consumed
shl rdx, 3
push rcx
call memmove
pop rcx
mov rsp, rax
sub qword[rsp +2*8], 1
loop create_opt_loop_1608
done_fixing_1607:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
mov rax, const_tbl+51
push rax
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*1]
push rax
push 3
;Var' ( VarBound ( fold-left , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 7
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_1605:
leave
ret
Lcont_1598:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+18*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+4*8]
push rax
mov rax, qword[fvar_tbl+17*8]
push rax
mov rax, qword[fvar_tbl+19*8]
push rax
mov rax, qword[fvar_tbl+28*8]
push rax
push 4
;(LambdaSimple'(  ( apply , - , + , null? ) , [(LambdaOpt'(  ( x . y ), , [(If'( Applic'( Var' ( VarBound ( null? , 0 , 0 )) , [Var' ( VarParam ( y , 1 ))] ) , ApplicTP'( Var' ( VarBound ( - , 0 , 0 )) , [Const' ( 0) , Var' ( VarParam ( x , 0 ))] ),ApplicTP'( Var' ( VarBound ( - , 0 , 0 )) , [Var' ( VarParam ( x , 0 )) , Applic'( Var' ( VarBound ( apply , 0 , 0 )) , [Var' ( VarBound ( + , 0 , 0 )) , Var' ( VarParam ( y , 1 ))] )] ) )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1664
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1665
is_not_empty_1664:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1666:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1666
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1668
params_loop_1667:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1667
no_more_params_1668:
mov qword[rdx], rbx
is_empty_1665:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1669)
jmp Lcont_1670
Lcode_1669:
push rbp
mov rbp, rsp
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1671
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1672
is_not_empty_1671:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1673:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1673
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1675
params_loop_1674:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1674
no_more_params_1675:
mov qword[rdx], rbx
is_empty_1672:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1676)
jmp Lcont_1677
Lcode_1676:
;donte the effective numer of parameters m
;donte the number of simple parameters n
mov rcx, qword[rsp+ 8*2]; rcx is m
cmp rcx, 1
jne not_empty_opt_1678
; m = n
add rcx, 3;m+2 - offset of magic
shl rcx, 3
mov qword[rsp+rcx], SOB_NIL_ADDRESS; magic is NIL
jmp done_fixing_1679
not_empty_opt_1678:
add rcx, 2; rcx is m+2 - the offset of the ultimetly last argument
mov rdi, rcx
mov rbx, qword[rsp+8*rdi]
MAKE_PAIR(rdx, rbx, SOB_NIL_ADDRESS)
mov qword[rsp+8*rdi], rdx;Arg_m-1 contains '(Arg_n-1)
sub rcx, 2; rcx is m
sub rcx, 1; rcx is m-n
dec rcx; because we've already handled the top opt param
cmp rcx, 0
je done_fixing_1679
;rcx is the number of optional parameters left (i.e. (m-n)-1)
create_opt_loop_1680:
mov rdx, rcx; rdx is curr_m (i.e: (m-n) - i, i.e the current amount of not consumed optional args left)
dec rdx; rdx is now offset
add rdx, 3; offset of arg_0+(curr_m-1)
add rdx, 1; offset of last optional param not consumed
mov rbx, qword[rsp + 8*rdx]
mov rdi, qword[rsp + 8*(rdx +1)]
MAKE_PAIR(rsi, rbx, rdi)
mov qword[rsp + 8*(rdx +1)], rsi
mov rax, 0
mov rdi, rsp
add rdi, 8; destination
mov rsi, rsp;source
mov rdx, 1;n
add rdx, 3; n+3
add rdx, rcx;n+3+curr_m
dec rdx; because the last opttion param have been consumed
shl rdx, 3
push rcx
call memmove
pop rcx
mov rsp, rax
sub qword[rsp +2*8], 1
loop create_opt_loop_1680
done_fixing_1679:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( null? , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*3]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_1756
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
mov rax, const_tbl+60
push rax
push 2
;Var' ( VarBound ( - , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
jmp Lexit_1757
Lelse_1756:
push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*2]
push rax
push 2
;Var' ( VarBound ( apply , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;Var' ( VarBound ( - , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
Lexit_1757:
leave
ret
Lcont_1677:
leave
ret
Lcont_1670:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+19*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+4*8]
push rax
mov rax, qword[fvar_tbl+18*8]
push rax
mov rax, qword[fvar_tbl+20*8]
push rax
mov rax, qword[fvar_tbl+28*8]
push rax
push 4
;(LambdaSimple'(  ( apply , / , * , null? ) , [(LambdaOpt'(  ( x . y ), , [(If'( Applic'( Var' ( VarBound ( null? , 0 , 0 )) , [Var' ( VarParam ( y , 1 ))] ) , ApplicTP'( Var' ( VarBound ( / , 0 , 0 )) , [Const' ( 1) , Var' ( VarParam ( x , 0 ))] ),ApplicTP'( Var' ( VarBound ( / , 0 , 0 )) , [Var' ( VarParam ( x , 0 )) , Applic'( Var' ( VarBound ( apply , 0 , 0 )) , [Var' ( VarBound ( * , 0 , 0 )) , Var' ( VarParam ( y , 1 ))] )] ) )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1788
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1789
is_not_empty_1788:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1790:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1790
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1792
params_loop_1791:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1791
no_more_params_1792:
mov qword[rdx], rbx
is_empty_1789:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1793)
jmp Lcont_1794
Lcode_1793:
push rbp
mov rbp, rsp
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1795
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1796
is_not_empty_1795:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1797:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1797
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1799
params_loop_1798:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1798
no_more_params_1799:
mov qword[rdx], rbx
is_empty_1796:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1800)
jmp Lcont_1801
Lcode_1800:
;donte the effective numer of parameters m
;donte the number of simple parameters n
mov rcx, qword[rsp+ 8*2]; rcx is m
cmp rcx, 1
jne not_empty_opt_1802
; m = n
add rcx, 3;m+2 - offset of magic
shl rcx, 3
mov qword[rsp+rcx], SOB_NIL_ADDRESS; magic is NIL
jmp done_fixing_1803
not_empty_opt_1802:
add rcx, 2; rcx is m+2 - the offset of the ultimetly last argument
mov rdi, rcx
mov rbx, qword[rsp+8*rdi]
MAKE_PAIR(rdx, rbx, SOB_NIL_ADDRESS)
mov qword[rsp+8*rdi], rdx;Arg_m-1 contains '(Arg_n-1)
sub rcx, 2; rcx is m
sub rcx, 1; rcx is m-n
dec rcx; because we've already handled the top opt param
cmp rcx, 0
je done_fixing_1803
;rcx is the number of optional parameters left (i.e. (m-n)-1)
create_opt_loop_1804:
mov rdx, rcx; rdx is curr_m (i.e: (m-n) - i, i.e the current amount of not consumed optional args left)
dec rdx; rdx is now offset
add rdx, 3; offset of arg_0+(curr_m-1)
add rdx, 1; offset of last optional param not consumed
mov rbx, qword[rsp + 8*rdx]
mov rdi, qword[rsp + 8*(rdx +1)]
MAKE_PAIR(rsi, rbx, rdi)
mov qword[rsp + 8*(rdx +1)], rsi
mov rax, 0
mov rdi, rsp
add rdi, 8; destination
mov rsi, rsp;source
mov rdx, 1;n
add rdx, 3; n+3
add rdx, rcx;n+3+curr_m
dec rdx; because the last opttion param have been consumed
shl rdx, 3
push rcx
call memmove
pop rcx
mov rsp, rax
sub qword[rsp +2*8], 1
loop create_opt_loop_1804
done_fixing_1803:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( null? , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*3]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_1880
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
mov rax, const_tbl+51
push rax
push 2
;Var' ( VarBound ( / , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
jmp Lexit_1881
Lelse_1880:
push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*2]
push rax
push 2
;Var' ( VarBound ( apply , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;Var' ( VarBound ( / , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
Lexit_1881:
leave
ret
Lcont_1801:
leave
ret
Lcont_1794:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+20*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+28*8]
push rax
mov rax, qword[fvar_tbl+25*8]
push rax
mov rax, qword[fvar_tbl+24*8]
push rax
mov rax, qword[fvar_tbl+4*8]
push rax
mov rax, qword[fvar_tbl+22*8]
push rax
push 5
;(LambdaSimple'(  ( = , null? , car , cdr , apply ) , [ApplicTP'( (LambdaSimple'(  ( =-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( =-loop , 0 )) , (Box'( VarParam ( =-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( =-loop , 0 ) , (LambdaOpt'(  ( x . y ), , [(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] ) , Const' ( true),(If'( Applic'( Var' ( VarBound ( = , 1 , 1 )) , [Var' ( VarParam ( x , 0 )) , Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] )] ) , ApplicTP'( Var' ( VarBound ( apply , 1 , 1 )) , [(BoxGet'( VarBound ( =-loop , 0 , 0 ) ) , Var' ( VarParam ( x , 0 )) , Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] )] ),Const' ( false) ) )] ) ) , (BoxGet'( VarParam ( =-loop , 0 ) )] )] )] ) , [Const' ( Symbol(whatever))] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1917
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1918
is_not_empty_1917:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1919:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1919
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1921
params_loop_1920:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1920
no_more_params_1921:
mov qword[rdx], rbx
is_empty_1918:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1922)
jmp Lcont_1923
Lcode_1922:
push rbp
mov rbp, rsp
push 496351

mov rax, const_tbl+42
push rax
push 1
;(LambdaSimple'(  ( =-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( =-loop , 0 )) , (Box'( VarParam ( =-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( =-loop , 0 ) , (LambdaOpt'(  ( x . y ), , [(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] ) , Const' ( true),(If'( Applic'( Var' ( VarBound ( = , 1 , 1 )) , [Var' ( VarParam ( x , 0 )) , Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] )] ) , ApplicTP'( Var' ( VarBound ( apply , 1 , 1 )) , [(BoxGet'( VarBound ( =-loop , 0 , 0 ) ) , Var' ( VarParam ( x , 0 )) , Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] )] ),Const' ( false) ) )] ) ) , (BoxGet'( VarParam ( =-loop , 0 ) )] )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1934
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1935
is_not_empty_1934:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1936:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1936
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1938
params_loop_1937:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1937
no_more_params_1938:
mov qword[rdx], rbx
is_empty_1935:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1939)
jmp Lcont_1940
Lcode_1939:
push rbp
mov rbp, rsp
mov rax, qword [rbp+8*(4+0)]
MALLOC rbx, 8
mov qword[rbx], rax
mov rax, rbx
mov qword [rbp+8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_1976
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_1977
is_not_empty_1976:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_1978:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_1978
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_1980
params_loop_1979:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_1979
no_more_params_1980:
mov qword[rdx], rbx
is_empty_1977:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_1981)
jmp Lcont_1982
Lcode_1981:
;donte the effective numer of parameters m
;donte the number of simple parameters n
mov rcx, qword[rsp+ 8*2]; rcx is m
cmp rcx, 1
jne not_empty_opt_1983
; m = n
add rcx, 3;m+2 - offset of magic
shl rcx, 3
mov qword[rsp+rcx], SOB_NIL_ADDRESS; magic is NIL
jmp done_fixing_1984
not_empty_opt_1983:
add rcx, 2; rcx is m+2 - the offset of the ultimetly last argument
mov rdi, rcx
mov rbx, qword[rsp+8*rdi]
MAKE_PAIR(rdx, rbx, SOB_NIL_ADDRESS)
mov qword[rsp+8*rdi], rdx;Arg_m-1 contains '(Arg_n-1)
sub rcx, 2; rcx is m
sub rcx, 1; rcx is m-n
dec rcx; because we've already handled the top opt param
cmp rcx, 0
je done_fixing_1984
;rcx is the number of optional parameters left (i.e. (m-n)-1)
create_opt_loop_1985:
mov rdx, rcx; rdx is curr_m (i.e: (m-n) - i, i.e the current amount of not consumed optional args left)
dec rdx; rdx is now offset
add rdx, 3; offset of arg_0+(curr_m-1)
add rdx, 1; offset of last optional param not consumed
mov rbx, qword[rsp + 8*rdx]
mov rdi, qword[rsp + 8*(rdx +1)]
MAKE_PAIR(rsi, rbx, rdi)
mov qword[rsp + 8*(rdx +1)], rsi
mov rax, 0
mov rdi, rsp
add rdi, 8; destination
mov rsi, rsp;source
mov rdx, 1;n
add rdx, 3; n+3
add rdx, rcx;n+3+curr_m
dec rdx; because the last opttion param have been consumed
shl rdx, 3
push rcx
call memmove
pop rcx
mov rsp, rax
sub qword[rsp +2*8], 1
loop create_opt_loop_1985
done_fixing_1984:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( null? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_2093
mov rax, const_tbl+0
jmp Lexit_2094
Lelse_2093:
push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( car , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*2]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;Var' ( VarBound ( = , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_2091
push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( cdr , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*3]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]
mov rax, qword[rax]
push rax
push 3
;Var' ( VarBound ( apply , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*4]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 7
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
jmp Lexit_2092
Lelse_2091:
mov rax, const_tbl+2
Lexit_2092:
Lexit_2094:
leave
ret
Lcont_1982:
push rax
mov rax, qword [rbp+8*(4+0)]
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp+8*(4+0)]
mov rax, qword[rax]
leave
ret
Lcont_1940:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 5
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_1923:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+22*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+25*8]
push rax
mov rax, qword[fvar_tbl+24*8]
push rax
mov rax, qword[fvar_tbl+21*8]
push rax
mov rax, qword[fvar_tbl+4*8]
push rax
push 4
;(LambdaSimple'(  ( null? , < , car , cdr ) , [ApplicTP'( (LambdaSimple'(  ( <-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( <-loop , 0 )) , (Box'( VarParam ( <-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( <-loop , 0 ) , (LambdaSimple'(  ( element , lst ) , [(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] ) , Const' ( true),(If'( Applic'( Var' ( VarBound ( < , 1 , 1 )) , [Var' ( VarParam ( element , 0 )) , Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] )] ) , ApplicTP'( (BoxGet'( VarBound ( <-loop , 0 , 0 ) ) , [Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] ) , Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] )] ),Const' ( false) ) )] ) ) , (LambdaOpt'(  ( x . y ), , [ApplicTP'( (BoxGet'( VarBound ( <-loop , 0 , 0 ) ) , [Var' ( VarParam ( x , 0 )) , Var' ( VarParam ( y , 1 ))] )] )] )] )] ) , [Const' ( Symbol(whatever))] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_2135
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_2136
is_not_empty_2135:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_2137:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_2137
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_2139
params_loop_2138:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_2138
no_more_params_2139:
mov qword[rdx], rbx
is_empty_2136:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_2140)
jmp Lcont_2141
Lcode_2140:
push rbp
mov rbp, rsp
push 496351

mov rax, const_tbl+42
push rax
push 1
;(LambdaSimple'(  ( <-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( <-loop , 0 )) , (Box'( VarParam ( <-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( <-loop , 0 ) , (LambdaSimple'(  ( element , lst ) , [(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] ) , Const' ( true),(If'( Applic'( Var' ( VarBound ( < , 1 , 1 )) , [Var' ( VarParam ( element , 0 )) , Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] )] ) , ApplicTP'( (BoxGet'( VarBound ( <-loop , 0 , 0 ) ) , [Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] ) , Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] )] ),Const' ( false) ) )] ) ) , (LambdaOpt'(  ( x . y ), , [ApplicTP'( (BoxGet'( VarBound ( <-loop , 0 , 0 ) ) , [Var' ( VarParam ( x , 0 )) , Var' ( VarParam ( y , 1 ))] )] )] )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_2152
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_2153
is_not_empty_2152:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_2154:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_2154
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_2156
params_loop_2155:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_2155
no_more_params_2156:
mov qword[rdx], rbx
is_empty_2153:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_2157)
jmp Lcont_2158
Lcode_2157:
push rbp
mov rbp, rsp
mov rax, qword [rbp+8*(4+0)]
MALLOC rbx, 8
mov qword[rbx], rax
mov rax, rbx
mov qword [rbp+8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_2194
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_2195
is_not_empty_2194:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_2196:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_2196
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_2198
params_loop_2197:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_2197
no_more_params_2198:
mov qword[rdx], rbx
is_empty_2195:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_2199)
jmp Lcont_2200
Lcode_2199:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( null? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_2313
mov rax, const_tbl+0
jmp Lexit_2314
Lelse_2313:
push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( car , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*2]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;Var' ( VarBound ( < , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_2311
push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( cdr , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*3]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( car , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*2]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 2
;(BoxGet'( VarBound ( <-loop , 0 , 0 ) )
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]
mov rax, qword[rax]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
jmp Lexit_2312
Lelse_2311:
mov rax, const_tbl+2
Lexit_2312:
Lexit_2314:
leave
ret
Lcont_2200:
push rax
mov rax, qword [rbp+8*(4+0)]
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_2315
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_2316
is_not_empty_2315:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_2317:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_2317
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_2319
params_loop_2318:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_2318
no_more_params_2319:
mov qword[rdx], rbx
is_empty_2316:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_2320)
jmp Lcont_2321
Lcode_2320:
;donte the effective numer of parameters m
;donte the number of simple parameters n
mov rcx, qword[rsp+ 8*2]; rcx is m
cmp rcx, 1
jne not_empty_opt_2322
; m = n
add rcx, 3;m+2 - offset of magic
shl rcx, 3
mov qword[rsp+rcx], SOB_NIL_ADDRESS; magic is NIL
jmp done_fixing_2323
not_empty_opt_2322:
add rcx, 2; rcx is m+2 - the offset of the ultimetly last argument
mov rdi, rcx
mov rbx, qword[rsp+8*rdi]
MAKE_PAIR(rdx, rbx, SOB_NIL_ADDRESS)
mov qword[rsp+8*rdi], rdx;Arg_m-1 contains '(Arg_n-1)
sub rcx, 2; rcx is m
sub rcx, 1; rcx is m-n
dec rcx; because we've already handled the top opt param
cmp rcx, 0
je done_fixing_2323
;rcx is the number of optional parameters left (i.e. (m-n)-1)
create_opt_loop_2324:
mov rdx, rcx; rdx is curr_m (i.e: (m-n) - i, i.e the current amount of not consumed optional args left)
dec rdx; rdx is now offset
add rdx, 3; offset of arg_0+(curr_m-1)
add rdx, 1; offset of last optional param not consumed
mov rbx, qword[rsp + 8*rdx]
mov rdi, qword[rsp + 8*(rdx +1)]
MAKE_PAIR(rsi, rbx, rdi)
mov qword[rsp + 8*(rdx +1)], rsi
mov rax, 0
mov rdi, rsp
add rdi, 8; destination
mov rsi, rsp;source
mov rdx, 1;n
add rdx, 3; n+3
add rdx, rcx;n+3+curr_m
dec rdx; because the last opttion param have been consumed
shl rdx, 3
push rcx
call memmove
pop rcx
mov rsp, rax
sub qword[rsp +2*8], 1
loop create_opt_loop_2324
done_fixing_2323:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;(BoxGet'( VarBound ( <-loop , 0 , 0 ) )
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]
mov rax, qword[rax]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_2321:
leave
ret
Lcont_2158:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 5
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_2141:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+21*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+25*8]
push rax
mov rax, qword[fvar_tbl+24*8]
push rax
mov rax, qword[fvar_tbl+37*8]
push rax
mov rax, qword[fvar_tbl+22*8]
push rax
mov rax, qword[fvar_tbl+21*8]
push rax
mov rax, qword[fvar_tbl+4*8]
push rax
push 6
;(LambdaSimple'(  ( null? , < , = , not , car , cdr ) , [ApplicTP'( (LambdaSimple'(  ( >-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( >-loop , 0 )) , (Box'( VarParam ( >-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( >-loop , 0 ) , (LambdaSimple'(  ( element , lst ) , [(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] ) , Const' ( true),(If'( Applic'( Var' ( VarBound ( not , 1 , 1 )) , [(Or'( Applic'( Var' ( VarBound ( < , 1 , 1 )) , [Var' ( VarParam ( element , 0 )) , Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] )] ) , Applic'( Var' ( VarBound ( = , 1 , 1 )) , [Var' ( VarParam ( element , 0 )) , Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] )] ) )] ) , ApplicTP'( (BoxGet'( VarBound ( >-loop , 0 , 0 ) ) , [Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] ) , Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] )] ),Const' ( false) ) )] ) ) , (LambdaOpt'(  ( x . y ), , [ApplicTP'( (BoxGet'( VarBound ( >-loop , 0 , 0 ) ) , [Var' ( VarParam ( x , 0 )) , Var' ( VarParam ( y , 1 ))] )] )] )] )] ) , [Const' ( Symbol(whatever))] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_2390
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_2391
is_not_empty_2390:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_2392:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_2392
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_2394
params_loop_2393:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_2393
no_more_params_2394:
mov qword[rdx], rbx
is_empty_2391:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_2395)
jmp Lcont_2396
Lcode_2395:
push rbp
mov rbp, rsp
push 496351

mov rax, const_tbl+42
push rax
push 1
;(LambdaSimple'(  ( >-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( >-loop , 0 )) , (Box'( VarParam ( >-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( >-loop , 0 ) , (LambdaSimple'(  ( element , lst ) , [(If'( Applic'( Var' ( VarBound ( null? , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] ) , Const' ( true),(If'( Applic'( Var' ( VarBound ( not , 1 , 1 )) , [(Or'( Applic'( Var' ( VarBound ( < , 1 , 1 )) , [Var' ( VarParam ( element , 0 )) , Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] )] ) , Applic'( Var' ( VarBound ( = , 1 , 1 )) , [Var' ( VarParam ( element , 0 )) , Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] )] ) )] ) , ApplicTP'( (BoxGet'( VarBound ( >-loop , 0 , 0 ) ) , [Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] ) , Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( lst , 1 ))] )] ),Const' ( false) ) )] ) ) , (LambdaOpt'(  ( x . y ), , [ApplicTP'( (BoxGet'( VarBound ( >-loop , 0 , 0 ) ) , [Var' ( VarParam ( x , 0 )) , Var' ( VarParam ( y , 1 ))] )] )] )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_2407
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_2408
is_not_empty_2407:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_2409:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_2409
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_2411
params_loop_2410:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_2410
no_more_params_2411:
mov qword[rdx], rbx
is_empty_2408:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_2412)
jmp Lcont_2413
Lcode_2412:
push rbp
mov rbp, rsp
mov rax, qword [rbp+8*(4+0)]
MALLOC rbx, 8
mov qword[rbx], rax
mov rax, rbx
mov qword [rbp+8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_2449
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_2450
is_not_empty_2449:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_2451:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_2451
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_2453
params_loop_2452:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_2452
no_more_params_2453:
mov qword[rdx], rbx
is_empty_2450:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_2454)
jmp Lcont_2455
Lcode_2454:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( null? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_2614
mov rax, const_tbl+0
jmp Lexit_2615
Lelse_2614:
push 496351

push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( car , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*4]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;Var' ( VarBound ( < , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS 
 jne Lexit_2496 
push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( car , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*4]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;Var' ( VarBound ( = , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*2]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
Lexit_2496:

push rax
push 1
;Var' ( VarBound ( not , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*3]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_2612
push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( cdr , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*5]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( car , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*4]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 2
;(BoxGet'( VarBound ( >-loop , 0 , 0 ) )
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]
mov rax, qword[rax]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
jmp Lexit_2613
Lelse_2612:
mov rax, const_tbl+2
Lexit_2613:
Lexit_2615:
leave
ret
Lcont_2455:
push rax
mov rax, qword [rbp+8*(4+0)]
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_2616
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_2617
is_not_empty_2616:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_2618:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_2618
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_2620
params_loop_2619:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_2619
no_more_params_2620:
mov qword[rdx], rbx
is_empty_2617:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_2621)
jmp Lcont_2622
Lcode_2621:
;donte the effective numer of parameters m
;donte the number of simple parameters n
mov rcx, qword[rsp+ 8*2]; rcx is m
cmp rcx, 1
jne not_empty_opt_2623
; m = n
add rcx, 3;m+2 - offset of magic
shl rcx, 3
mov qword[rsp+rcx], SOB_NIL_ADDRESS; magic is NIL
jmp done_fixing_2624
not_empty_opt_2623:
add rcx, 2; rcx is m+2 - the offset of the ultimetly last argument
mov rdi, rcx
mov rbx, qword[rsp+8*rdi]
MAKE_PAIR(rdx, rbx, SOB_NIL_ADDRESS)
mov qword[rsp+8*rdi], rdx;Arg_m-1 contains '(Arg_n-1)
sub rcx, 2; rcx is m
sub rcx, 1; rcx is m-n
dec rcx; because we've already handled the top opt param
cmp rcx, 0
je done_fixing_2624
;rcx is the number of optional parameters left (i.e. (m-n)-1)
create_opt_loop_2625:
mov rdx, rcx; rdx is curr_m (i.e: (m-n) - i, i.e the current amount of not consumed optional args left)
dec rdx; rdx is now offset
add rdx, 3; offset of arg_0+(curr_m-1)
add rdx, 1; offset of last optional param not consumed
mov rbx, qword[rsp + 8*rdx]
mov rdi, qword[rsp + 8*(rdx +1)]
MAKE_PAIR(rsi, rbx, rdi)
mov qword[rsp + 8*(rdx +1)], rsi
mov rax, 0
mov rdi, rsp
add rdi, 8; destination
mov rsi, rsp;source
mov rdx, 1;n
add rdx, 3; n+3
add rdx, rcx;n+3+curr_m
dec rdx; because the last opttion param have been consumed
shl rdx, 3
push rcx
call memmove
pop rcx
mov rsp, rax
sub qword[rsp +2*8], 1
loop create_opt_loop_2625
done_fixing_2624:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;(BoxGet'( VarBound ( >-loop , 0 , 0 ) )
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]
mov rax, qword[rax]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_2622:
leave
ret
Lcont_2413:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 5
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_2396:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+39*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+22*8]
push rax
push 1
;(LambdaSimple'(  ( = ) , [(LambdaSimple'(  ( x ) , [ApplicTP'( Var' ( VarBound ( = , 0 , 0 )) , [Var' ( VarParam ( x , 0 )) , Const' ( 0)] )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_2666
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_2667
is_not_empty_2666:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_2668:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_2668
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_2670
params_loop_2669:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_2669
no_more_params_2670:
mov qword[rdx], rbx
is_empty_2667:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_2671)
jmp Lcont_2672
Lcode_2671:
push rbp
mov rbp, rsp
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_2673
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_2674
is_not_empty_2673:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_2675:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_2675
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_2677
params_loop_2676:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_2676
no_more_params_2677:
mov qword[rdx], rbx
is_empty_2674:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_2678)
jmp Lcont_2679
Lcode_2678:
push rbp
mov rbp, rsp
push 496351

mov rax, const_tbl+60
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;Var' ( VarBound ( = , 0 , 0 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_2679:
leave
ret
Lcont_2672:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+40*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+19*8]
push rax
mov rax, qword[fvar_tbl+21*8]
push rax
mov rax, qword[fvar_tbl+9*8]
push rax
mov rax, qword[fvar_tbl+10*8]
push rax
push 4
;(LambdaSimple'(  ( string-ref , string-length , < , - ) , [(LambdaSimple'(  ( s ) , [ApplicTP'( (LambdaSimple'(  ( s->l-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( s->l-loop , 0 )) , (Box'( VarParam ( s->l-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( s->l-loop , 0 ) , (LambdaSimple'(  ( n , a ) , [(If'( Applic'( Var' ( VarBound ( < , 2 , 2 )) , [Var' ( VarParam ( n , 0 )) , Const' ( 0)] ) , Var' ( VarParam ( a , 1 )),ApplicTP'( (BoxGet'( VarBound ( s->l-loop , 0 , 0 ) ) , [Applic'( Var' ( VarBound ( - , 2 , 2 )) , [Var' ( VarParam ( n , 0 )) , Const' ( 1)] ) , Applic'( Var' ( VarFree ( cons )) , [Applic'( Var' ( VarBound ( string-ref , 2 , 2 )) , [Var' ( VarBound ( s , 1 , 1 )) , Var' ( VarParam ( n , 0 ))] ) , Var' ( VarParam ( a , 1 ))] )] ) )] ) ) , ApplicTP'( (BoxGet'( VarParam ( s->l-loop , 0 ) ) , [Applic'( Var' ( VarBound ( - , 1 , 1 )) , [Applic'( Var' ( VarBound ( string-length , 1 , 1 )) , [Var' ( VarBound ( s , 0 , 0 ))] ) , Const' ( 1)] ) , Const' ( Nil)] )] )] )] ) , [Const' ( Symbol(whatever))] )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_2730
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_2731
is_not_empty_2730:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_2732:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_2732
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_2734
params_loop_2733:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_2733
no_more_params_2734:
mov qword[rdx], rbx
is_empty_2731:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_2735)
jmp Lcont_2736
Lcode_2735:
push rbp
mov rbp, rsp
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_2737
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_2738
is_not_empty_2737:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_2739:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_2739
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_2741
params_loop_2740:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_2740
no_more_params_2741:
mov qword[rdx], rbx
is_empty_2738:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_2742)
jmp Lcont_2743
Lcode_2742:
push rbp
mov rbp, rsp
push 496351

mov rax, const_tbl+42
push rax
push 1
;(LambdaSimple'(  ( s->l-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( s->l-loop , 0 )) , (Box'( VarParam ( s->l-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( s->l-loop , 0 ) , (LambdaSimple'(  ( n , a ) , [(If'( Applic'( Var' ( VarBound ( < , 2 , 2 )) , [Var' ( VarParam ( n , 0 )) , Const' ( 0)] ) , Var' ( VarParam ( a , 1 )),ApplicTP'( (BoxGet'( VarBound ( s->l-loop , 0 , 0 ) ) , [Applic'( Var' ( VarBound ( - , 2 , 2 )) , [Var' ( VarParam ( n , 0 )) , Const' ( 1)] ) , Applic'( Var' ( VarFree ( cons )) , [Applic'( Var' ( VarBound ( string-ref , 2 , 2 )) , [Var' ( VarBound ( s , 1 , 1 )) , Var' ( VarParam ( n , 0 ))] ) , Var' ( VarParam ( a , 1 ))] )] ) )] ) ) , ApplicTP'( (BoxGet'( VarParam ( s->l-loop , 0 ) ) , [Applic'( Var' ( VarBound ( - , 1 , 1 )) , [Applic'( Var' ( VarBound ( string-length , 1 , 1 )) , [Var' ( VarBound ( s , 0 , 0 ))] ) , Const' ( 1)] ) , Const' ( Nil)] )] )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_2754
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_2755
is_not_empty_2754:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_2756:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_2756
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_2758
params_loop_2757:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_2757
no_more_params_2758:
mov qword[rdx], rbx
is_empty_2755:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_2759)
jmp Lcont_2760
Lcode_2759:
push rbp
mov rbp, rsp
mov rax, qword [rbp+8*(4+0)]
MALLOC rbx, 8
mov qword[rbx], rax
mov rax, rbx
mov qword [rbp+8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_2796
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_2797
is_not_empty_2796:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_2798:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_2798
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_2800
params_loop_2799:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_2799
no_more_params_2800:
mov qword[rdx], rbx
is_empty_2797:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_2801)
jmp Lcont_2802
Lcode_2801:
push rbp
mov rbp, rsp
push 496351

mov rax, const_tbl+60
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;Var' ( VarBound ( < , 2 , 2 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*2]
mov rax, qword[rax+8*2]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_2903
mov rax, qword [rbp+8*(4+1)]
jmp Lexit_2904
Lelse_2903:
push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*0]
push rax
push 2
;Var' ( VarBound ( string-ref , 2 , 2 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*2]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 2
;Var' ( VarFree ( cons ))
mov rax, qword[fvar_tbl+23*8]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 496351

mov rax, const_tbl+51
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;Var' ( VarBound ( - , 2 , 2 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*2]
mov rax, qword[rax+8*3]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 2
;(BoxGet'( VarBound ( s->l-loop , 0 , 0 ) )
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]
mov rax, qword[rax]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
Lexit_2904:
leave
ret
Lcont_2802:
push rax
mov rax, qword [rbp+8*(4+0)]
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
push 496351

mov rax, const_tbl+4
push rax
push 496351

mov rax, const_tbl+51
push rax
push 496351

mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]
push rax
push 1
;Var' ( VarBound ( string-length , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 2
;Var' ( VarBound ( - , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*3]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 2
;(BoxGet'( VarParam ( s->l-loop , 0 ) )
mov rax, qword [rbp+8*(4+0)]
mov rax, qword[rax]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_2760:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 5
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_2743:
leave
ret
Lcont_2736:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+41*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 496351

mov rax, qword[fvar_tbl+14*8]
push rax
mov rax, qword[fvar_tbl+25*8]
push rax
mov rax, qword[fvar_tbl+24*8]
push rax
mov rax, qword[fvar_tbl+16*8]
push rax
mov rax, qword[fvar_tbl+6*8]
push rax
mov rax, qword[fvar_tbl+5*8]
push rax
mov rax, qword[fvar_tbl+3*8]
push rax
mov rax, qword[fvar_tbl+1*8]
push rax
mov rax, qword[fvar_tbl+2*8]
push rax
mov rax, qword[fvar_tbl+41*8]
push rax
mov rax, qword[fvar_tbl+22*8]
push rax
push 11
;(LambdaSimple'(  ( = , string->list , integer? , float? , pair? , char? , string? , eq? , car , cdr , char->integer ) , [ApplicTP'( (LambdaSimple'(  ( equal?-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( equal?-loop , 0 )) , (Box'( VarParam ( equal?-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( equal?-loop , 0 ) , (LambdaSimple'(  ( x , y ) , [(Or'( (If'( Applic'( Var' ( VarBound ( integer? , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , (If'( Applic'( Var' ( VarBound ( integer? , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] ) , Applic'( Var' ( VarBound ( = , 1 , 1 )) , [Var' ( VarParam ( x , 0 )) , Var' ( VarParam ( y , 1 ))] ),Const' ( false) ),Const' ( false) ) , (If'( Applic'( Var' ( VarBound ( float? , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , (If'( Applic'( Var' ( VarBound ( float? , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] ) , Applic'( Var' ( VarBound ( = , 1 , 1 )) , [Var' ( VarParam ( x , 0 )) , Var' ( VarParam ( y , 1 ))] ),Const' ( false) ),Const' ( false) ) , (If'( Applic'( Var' ( VarBound ( pair? , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , (If'( Applic'( Var' ( VarBound ( pair? , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] ) , (If'( Applic'( (BoxGet'( VarBound ( equal?-loop , 0 , 0 ) ) , [Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] )] ) , Applic'( (BoxGet'( VarBound ( equal?-loop , 0 , 0 ) ) , [Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] )] ),Const' ( false) ),Const' ( false) ),Const' ( false) ) , (If'( Applic'( Var' ( VarBound ( char? , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , (If'( Applic'( Var' ( VarBound ( char? , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] ) , Applic'( Var' ( VarBound ( = , 1 , 1 )) , [Applic'( Var' ( VarBound ( char->integer , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , Applic'( Var' ( VarBound ( char->integer , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] )] ),Const' ( false) ),Const' ( false) ) , (If'( Applic'( Var' ( VarBound ( string? , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , (If'( Applic'( Var' ( VarBound ( string? , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] ) , Applic'( (BoxGet'( VarBound ( equal?-loop , 0 , 0 ) ) , [Applic'( Var' ( VarBound ( string->list , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , Applic'( Var' ( VarBound ( string->list , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] )] ),Const' ( false) ),Const' ( false) ) , ApplicTP'( Var' ( VarBound ( eq? , 1 , 1 )) , [Var' ( VarParam ( x , 0 )) , Var' ( VarParam ( y , 1 ))] ) )] ) ) , (BoxGet'( VarParam ( equal?-loop , 0 ) )] )] )] ) , [Const' ( Symbol(whatever))] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_3020
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_3021
is_not_empty_3020:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_3022:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_3022
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_3024
params_loop_3023:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_3023
no_more_params_3024:
mov qword[rdx], rbx
is_empty_3021:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_3025)
jmp Lcont_3026
Lcode_3025:
push rbp
mov rbp, rsp
push 496351

mov rax, const_tbl+42
push rax
push 1
;(LambdaSimple'(  ( equal?-loop ) , [(Seq'( [(Set'( Var' ( VarParam ( equal?-loop , 0 )) , (Box'( VarParam ( equal?-loop , 0 ) ) ) , (Seq'( [(BoxSet'( VarParam ( equal?-loop , 0 ) , (LambdaSimple'(  ( x , y ) , [(Or'( (If'( Applic'( Var' ( VarBound ( integer? , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , (If'( Applic'( Var' ( VarBound ( integer? , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] ) , Applic'( Var' ( VarBound ( = , 1 , 1 )) , [Var' ( VarParam ( x , 0 )) , Var' ( VarParam ( y , 1 ))] ),Const' ( false) ),Const' ( false) ) , (If'( Applic'( Var' ( VarBound ( float? , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , (If'( Applic'( Var' ( VarBound ( float? , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] ) , Applic'( Var' ( VarBound ( = , 1 , 1 )) , [Var' ( VarParam ( x , 0 )) , Var' ( VarParam ( y , 1 ))] ),Const' ( false) ),Const' ( false) ) , (If'( Applic'( Var' ( VarBound ( pair? , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , (If'( Applic'( Var' ( VarBound ( pair? , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] ) , (If'( Applic'( (BoxGet'( VarBound ( equal?-loop , 0 , 0 ) ) , [Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , Applic'( Var' ( VarBound ( car , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] )] ) , Applic'( (BoxGet'( VarBound ( equal?-loop , 0 , 0 ) ) , [Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , Applic'( Var' ( VarBound ( cdr , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] )] ),Const' ( false) ),Const' ( false) ),Const' ( false) ) , (If'( Applic'( Var' ( VarBound ( char? , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , (If'( Applic'( Var' ( VarBound ( char? , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] ) , Applic'( Var' ( VarBound ( = , 1 , 1 )) , [Applic'( Var' ( VarBound ( char->integer , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , Applic'( Var' ( VarBound ( char->integer , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] )] ),Const' ( false) ),Const' ( false) ) , (If'( Applic'( Var' ( VarBound ( string? , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , (If'( Applic'( Var' ( VarBound ( string? , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] ) , Applic'( (BoxGet'( VarBound ( equal?-loop , 0 , 0 ) ) , [Applic'( Var' ( VarBound ( string->list , 1 , 1 )) , [Var' ( VarParam ( x , 0 ))] ) , Applic'( Var' ( VarBound ( string->list , 1 , 1 )) , [Var' ( VarParam ( y , 1 ))] )] ),Const' ( false) ),Const' ( false) ) , ApplicTP'( Var' ( VarBound ( eq? , 1 , 1 )) , [Var' ( VarParam ( x , 0 )) , Var' ( VarParam ( y , 1 ))] ) )] ) ) , (BoxGet'( VarParam ( equal?-loop , 0 ) )] )] )] )
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_3037
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_3038
is_not_empty_3037:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_3039:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_3039
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_3041
params_loop_3040:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_3040
no_more_params_3041:
mov qword[rdx], rbx
is_empty_3038:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_3042)
jmp Lcont_3043
Lcode_3042:
push rbp
mov rbp, rsp
mov rax, qword [rbp+8*(4+0)]
MALLOC rbx, 8
mov qword[rbx], rax
mov rax, rbx
mov qword [rbp+8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
GET_ENV rbx
mov rcx, 0
cmp rbx, SOB_NIL_ADDRESS
jne is_not_empty_3079
MALLOC rdx, 8
mov qword[rdx], SOB_NIL_ADDRESS
jmp is_empty_3080
is_not_empty_3079:
ENV_LENGTH rbx
mov rdi, rcx
inc rdi
shl rdi, 3
MALLOC rdx, rdi
env_loop_3081:
shl rcx, 3
mov rsi, rbx;Env
add rsi, rcx;Env[i]
sub rsi, 8;Env[i-1]
mov r8, rdx;ExtEnv
add r8, rcx;ExtEnv[i]
mov r9, qword[rsi];r9 is the i'th rib
mov qword[r8], r9; ExtEnv[i] = Env[i-1]
shr rcx, 3
loop env_loop_3081
mov rcx, qword[rbp +8*3]
shl rcx, 3
MALLOC rbx, rcx;rbx is the new rib
shr rcx, 3
cmp rcx, 0
je no_more_params_3083
params_loop_3082:
mov rdi, rcx
dec rdi;rdi is the 0 based index of the current arg
GET_ARG rsi, rdi
mov qword[rbx + rdi*8], rsi
loop params_loop_3082
no_more_params_3083:
mov qword[rdx], rbx
is_empty_3080:
;;RDX IS THE EXTENV!!!
MAKE_CLOSURE(rax, rdx, Lcode_3084)
jmp Lcont_3085
Lcode_3084:
push rbp
mov rbp, rsp
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
push 1
;Var' ( VarBound ( integer? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*2]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_3164
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( integer? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*2]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_3157
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;Var' ( VarBound ( = , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
jmp Lexit_3158
Lelse_3157:
mov rax, const_tbl+2
Lexit_3158:
jmp Lexit_3165
Lelse_3164:
mov rax, const_tbl+2
Lexit_3165:
cmp rax, SOB_FALSE_ADDRESS 
 jne Lexit_3091 
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
push 1
;Var' ( VarBound ( float? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*3]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_3238
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( float? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*3]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_3231
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;Var' ( VarBound ( = , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
jmp Lexit_3232
Lelse_3231:
mov rax, const_tbl+2
Lexit_3232:
jmp Lexit_3239
Lelse_3238:
mov rax, const_tbl+2
Lexit_3239:
cmp rax, SOB_FALSE_ADDRESS 
 jne Lexit_3091 
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
push 1
;Var' ( VarBound ( pair? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*4]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_3394
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( pair? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*4]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_3387
push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( car , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*8]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
push 1
;Var' ( VarBound ( car , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*8]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 2
;(BoxGet'( VarBound ( equal?-loop , 0 , 0 ) )
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]
mov rax, qword[rax]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_3380
push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( cdr , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*9]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
push 1
;Var' ( VarBound ( cdr , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*9]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 2
;(BoxGet'( VarBound ( equal?-loop , 0 , 0 ) )
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]
mov rax, qword[rax]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
jmp Lexit_3381
Lelse_3380:
mov rax, const_tbl+2
Lexit_3381:
jmp Lexit_3388
Lelse_3387:
mov rax, const_tbl+2
Lexit_3388:
jmp Lexit_3395
Lelse_3394:
mov rax, const_tbl+2
Lexit_3395:
cmp rax, SOB_FALSE_ADDRESS 
 jne Lexit_3091 
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
push 1
;Var' ( VarBound ( char? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*5]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_3488
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( char? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*5]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_3481
push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( char->integer , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*10]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
push 1
;Var' ( VarBound ( char->integer , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*10]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 2
;Var' ( VarBound ( = , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*0]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
jmp Lexit_3482
Lelse_3481:
mov rax, const_tbl+2
Lexit_3482:
jmp Lexit_3489
Lelse_3488:
mov rax, const_tbl+2
Lexit_3489:
cmp rax, SOB_FALSE_ADDRESS 
 jne Lexit_3091 
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
push 1
;Var' ( VarBound ( string? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*6]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_3587
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( string? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*6]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
cmp rax, SOB_FALSE_ADDRESS
je Lelse_3580
push 496351

push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
push 1
;Var' ( VarBound ( string->list , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 496351

mov rax, qword [rbp+8*(4+0)]
push rax
push 1
;Var' ( VarBound ( string->list , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*1]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
push rax
push 2
;(BoxGet'( VarBound ( equal?-loop , 0 , 0 ) )
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*0]
mov rax, qword[rax+8*0]
mov rax, qword[rax]

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
jmp Lexit_3581
Lelse_3580:
mov rax, const_tbl+2
Lexit_3581:
jmp Lexit_3588
Lelse_3587:
mov rax, const_tbl+2
Lexit_3588:
cmp rax, SOB_FALSE_ADDRESS 
 jne Lexit_3091 
push 496351

mov rax, qword [rbp+8*(4+1)]
push rax
mov rax, qword [rbp+8*(4+0)]
push rax
push 2
;Var' ( VarBound ( eq? , 1 , 1 ))
mov rax, qword[rbp+8*2]
mov rax, qword[rax+8*1]
mov rax, qword[rax+8*7]

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 6
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
Lexit_3091:

leave
ret
Lcont_3085:
push rax
mov rax, qword [rbp+8*(4+0)]
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp+8*(4+0)]
mov rax, qword[rax]
leave
ret
Lcont_3043:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp +8*1]
SHIFT_FRAME 5
CLOSURE_CODE rbx, rax
jmp rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
leave
ret
Lcont_3026:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1
pop rbx
inc rbx
shl rbx, 3
add rsp, rbx
mov qword[fvar_tbl+42*8], rax 
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rax, const_tbl+16
	call write_sob_if_not_void

	mov rax, 0
	add rsp, 4*8
	pop rbp
	ret

apply:
;;; (apply proc x0 ... xn-1 s)
;;; s id s_0 .. s_m-1

;;; TODO: add closure verification
	push rbp
	mov rbp, rsp
	push 496351
	mov rbx, qword[rbp+8*3]
	add rbx, 3
	mov rsi, qword[rbp + 8*rbx]	; rsi is s
	mov rdi, 0		;the length of s
push_s_loop:
	cmp rsi, SOB_NIL_ADDRESS
	je end_push_s
	inc rdi
	CAR rbx, rsi
	push rbx
	CDR rsi, rsi
	jmp push_s_loop
end_push_s:
;;; magic s0 ... sm-1 on the stack
	cmp rdi, 0
	je reverse_s_end
	mov rcx, rdi
	cmp rcx ,1
	jbe reverse_s_end
	shr rcx,1 		;rcx is m/2
reverse_s_loop:
	mov rdx, rcx
	dec rdx			    ;rdx is the index (e.g 0 based)
	mov rbx, qword[rsp + rdx*8] ;rbx is s_i
	mov r8, rdi
	dec r8			  ;r8 is the index of le last elemnt
	sub r8, rdx		;m-i
	mov r9, qword[rsp + r8*8] ; r9 is s_m-i
	mov qword[rsp + rdx*8], r9 
	mov qword[rsp + r8*8], rbx
	loop reverse_s_loop
reverse_s_end:
	mov rcx, qword[rbp+8*3]
	sub rcx, 2		;rdx is n
	mov rsi, rcx		;save it for later
	cmp rsi, 0
	je no_params
push_xs_loop:
	mov rdx, rcx
	dec rdx			;rdx is index
	add rdx, 5		;5  and not 4 because the first parameter is proc
	push qword[rbp +8*rdx]
	loop push_xs_loop
no_params:	
;;; magic s_m-1,..,s_0, x_n-1,..x_0 on the stack
	add rdi, rsi		  ;m+n
	push rdi
	mov r14, rdi
	add r14, ELEMENTS_ON_STACK_NO_RBP
	shl r14, 3
	mov rbx, qword[rbp + 8*4] ; rbx is proc
;;; verify that proc is (i.e rbx) a closue
	CLOSURE_ENV rdx, rbx
	push rdx
	mov r8, rbx		;save the closure
	push qword[rbp+8]	;ret address
	mov rdx, rsp 		;this is the source of the memmory move
	push r8
	mov rbx, GET_PARAM_COUNT		;calc memmory length
	add rbx, ELEMENTS_ON_STACK ;;cacl memmory length
	shl rbx, 3			  ;rbx is the number of bytes need to be moved
	mov rbp, qword[rbp]	;current rbp is no longer needed and old rbp need to be accesibl
	mov rsi, rdx
	add rsi, rbx		;src is dest + param_c +elements_on_stack
	mov rax, 0
	mov rdi, rsi		;dest
	mov rsi, rdx		;src
	mov rdx, r14		;len
	call memmove
	pop rbx			;proc
	mov rsp, rax
	CLOSURE_CODE rdx, rbx
	jmp rdx
	

	
	
	
	
	
	
	
cons:
	push rbp
	mov rbp, rsp
	GET_ARG rsi, 0
	GET_ARG rdx, 1
	MAKE_PAIR(rax, rsi, rdx)
	leave
	ret
car:
	push rbp
	mov rbp, rsp
	GET_ARG rsi, 0
	CAR rax, rsi
	leave
	ret

set_car:
	push rbp
	mov rbp, rsp
	GET_ARG rsi, 0
	GET_ARG rdi, 1
	mov qword[rsi+TYPE_SIZE], rdi
	mov rax, SOB_VOID_ADDRESS
	leave
	ret

set_cdr:
	push rbp
	mov rbp, rsp
	GET_ARG rsi, 0
	GET_ARG rdi, 1
	mov qword[rsi+TYPE_SIZE+WORD_SIZE], rdi
	mov rax, SOB_VOID_ADDRESS
	leave
	ret

cdr:
	push rbp
	mov rbp, rsp
	GET_ARG rsi, 0
	CDR rax, rsi
	leave
	ret
is_boolean:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_BOOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_float:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_FLOAT
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_integer:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_INTEGER
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_pair:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_PAIR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_null:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_NIL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_char:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CHAR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_string:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_STRING
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_procedure:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CLOSURE
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_symbol:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_SYMBOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

string_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    STRING_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

string_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov sil, byte [rsi]
    MAKE_CHAR(rax, sil)

    leave
    ret

string_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov rax, PVAR(2)
    CHAR_VAL rax, rax
    mov byte [rsi], al
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    CHAR_VAL rdi, rdi
    and rdi, 255

    MAKE_STRING rax, rsi, dil

    leave
    ret

symbol_to_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    SYMBOL_VAL rsi, rsi
    
    STRING_LENGTH rcx, rsi
    STRING_ELEMENTS rdi, rsi

    push rcx
    push rdi

    mov dil, byte [rdi]
    MAKE_CHAR(rax, dil)
    push rax
    MAKE_INT(rax, rcx)
    push rax
    push 2
    push SOB_NIL_ADDRESS
    call make_string
    add rsp, 4*8

    STRING_ELEMENTS rsi, rax

    pop rdi
    pop rcx

    cmp rcx, 0
    je .end
	
.loop:
    lea r8, [rdi+rcx]
    lea r9, [rsi+rcx]

    mov bl, byte [r8]
    mov byte [r9], bl
    
    loop .loop
.end:

    leave
    ret

char_to_integer:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    CHAR_VAL rsi, rsi
    and rsi, 255
    MAKE_INT(rax, rsi)

    leave
    ret

integer_to_char:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    and rsi, 255
    MAKE_CHAR(rax, sil)

    leave
    ret

is_eq:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    mov rdi, PVAR(1)
    cmp rsi, rdi
    je .true
    mov rax, SOB_FALSE_ADDRESS
    jmp .return

.true:
    mov rax, SOB_TRUE_ADDRESS

.return:
    leave
    ret

bin_add:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    addsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_mul:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    mulsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_sub:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    subsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_div:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    divsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_lt:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpltsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret

bin_equ:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpeqsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret


